package ai

import (
	"log"
	"regexp"
	"strings"

	tiktoken "github.com/pkoukk/tiktoken-go"
)

var enc *tiktoken.Tiktoken

func init() {
	var err error
	enc, err = tiktoken.EncodingForModel("gpt-3.5-turbo")
	if err != nil {
		log.Fatalf("Failed to initialize tokenizer: %v", err)
	}
}

// CountTokens returns the token count of input text
func CountTokens(text string) int {
	tokens := enc.Encode(text, nil, nil)
	if tokens == nil {
		return len([]rune(text)) / 4 // fallback guess
	}
	return len(tokens)
}

// cheapSkipFilter returns true if input should be skipped due to being trivial or generated
func cheapSkipFilter(input string) bool {
	trimmed := strings.TrimSpace(input)
	if len(trimmed) == 0 {
		return true
	}

	// Skip if too short (e.g. just braces, imports)
	if len(trimmed) < 10 {
		return true
	}

	// Regex for trivial lines like single braces, imports, or autogenerated comments
	trivialPatterns := []string{
		`^import\s+[\s\S]*`,                 // import blocks
		`^\{\s*\}$`,                         // single brace block
		`^//.*generated.*$`,                 // comments with "generated"
		`^// Code generated .* DO NOT EDIT`, // common autogenerated header
		`^package\s+\w+`,                    // just package statement alone
	}

	for _, pat := range trivialPatterns {
		re := regexp.MustCompile(pat)
		if re.MatchString(trimmed) {
			return true
		}
	}

	return false
}

// groupByTokenBudget splits snippet indexes into groups with total tokens below tokenBudget
func groupByTokenBudget(snippets []string, languages []string, tokenBudget int) [][]int {
	var groups [][]int
	var currentGroup []int
	currentTokens := 0

	for i, snippet := range snippets {
		if cheapSkipFilter(snippet) {
			continue
		}

		t := CountTokens(snippet)
		if currentTokens+t > tokenBudget && len(currentGroup) > 0 {
			groups = append(groups, currentGroup)
			currentGroup = nil
			currentTokens = 0
		}

		currentGroup = append(currentGroup, i)
		currentTokens += t
	}

	if len(currentGroup) > 0 {
		groups = append(groups, currentGroup)
	}

	return groups
}
